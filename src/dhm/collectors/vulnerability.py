"""
Vulnerability scanning clients for security databases.

Provides clients for OSV (Open Source Vulnerabilities) and other
security databases to check packages for known vulnerabilities.

Includes caching to reduce API calls (6 hour TTL for vulnerability data).
"""

import asyncio
from datetime import datetime
from typing import TYPE_CHECKING, Any

import aiohttp
from packaging.version import parse as parse_version

from dhm.collectors.base import Collector
from dhm.core.exceptions import NetworkError
from dhm.core.models import PackageIdentifier, RiskLevel, Vulnerability

if TYPE_CHECKING:
    from dhm.cache.sqlite import CacheLayer


def _compare_versions(v1: str, v2: str) -> int:
    """Compare two version strings using PEP 440 compliant parsing.

    Uses the `packaging` library for proper version comparison, including
    pre-release versions (alpha, beta, rc), post-releases, and dev versions.

    Returns:
        -1 if v1 < v2
         0 if v1 == v2
         1 if v1 > v2

    Raises:
        ValueError: If either version string is invalid.
    """
    parsed_v1 = parse_version(v1)
    parsed_v2 = parse_version(v2)

    if parsed_v1 < parsed_v2:
        return -1
    elif parsed_v1 > parsed_v2:
        return 1
    return 0


def _is_version_fixed(installed_version: str | None, fixed_version: str | None) -> bool:
    """Check if the installed version is at or above the fixed version.

    Uses PEP 440 compliant version comparison via the `packaging` library,
    correctly handling pre-release versions like 1.0.0b2 < 1.0.0b3 < 1.0.0.

    Args:
        installed_version: The version currently installed.
        fixed_version: The version that contains the fix.

    Returns:
        True if installed version is fixed (at or above fix version).
    """
    if not installed_version or not fixed_version:
        return False

    try:
        installed = parse_version(installed_version)
        fixed = parse_version(fixed_version)
        return installed >= fixed
    except Exception:
        # If version comparison fails, assume not fixed (safer default)
        return False


class OSVClient(Collector):
    """Client for Open Source Vulnerabilities (OSV) database.

    OSV is a distributed vulnerability database for open source projects.
    It provides a free API for querying vulnerabilities by package name
    and version.
    """

    BASE_URL = "https://api.osv.dev/v1"

    # Cache TTL: 6 hours for vulnerability data (important to stay current)
    CACHE_TTL = 21600  # 6 hours in seconds

    def __init__(
        self,
        session: aiohttp.ClientSession | None = None,
        timeout: int = 30,
        cache: "CacheLayer | None" = None,
    ):
        """Initialize the OSV client.

        Args:
            session: Optional aiohttp session.
            timeout: Request timeout in seconds.
            cache: Optional cache layer for storing API responses.
        """
        super().__init__(session, timeout)
        self.cache = cache

    async def fetch(self, identifier: str) -> list[Vulnerability]:
        """Fetch vulnerabilities for a package.

        Args:
            identifier: Package name.

        Returns:
            List of Vulnerability objects.
        """
        return await self.check(identifier, None)

    async def check(
        self,
        package: str,
        version: str | None,
    ) -> list[Vulnerability]:
        """Query OSV for vulnerabilities affecting a package.

        Uses cache (6 hour TTL) to reduce API calls while staying current
        on security data.

        Args:
            package: Package name.
            version: Optional specific version to check.

        Returns:
            List of Vulnerability objects with is_fixed_in_installed_version set.
        """
        # Check cache first (cache key includes package but NOT version,
        # since we fetch all vulns and filter by version client-side)
        cache_key = f"osv:vulns:{package}"
        cached_vulns = None

        if self.cache:
            cached_vulns = self.cache.get_value(cache_key)

        if cached_vulns is not None:
            # Reconstruct Vulnerability objects from cached dicts
            vulns = []
            for v_dict in cached_vulns:
                vuln = Vulnerability.from_dict(v_dict)
                # Re-apply version filtering
                if version and vuln.fixed_version:
                    vuln.is_fixed_in_installed_version = _is_version_fixed(
                        version, vuln.fixed_version
                    )
                vulns.append(vuln)
            return vulns

        payload: dict[str, Any] = {
            "package": {"name": package, "ecosystem": "PyPI"},
        }
        # Note: We query WITHOUT version to get ALL vulns, then filter ourselves
        # This lets us categorize as open vs fixed

        url = f"{self.BASE_URL}/query"

        try:
            async with self.session.post(
                url,
                headers=self._build_headers(),
                json=payload,
            ) as resp:
                if resp.status != 200:
                    # OSV returns 200 even for no results, so non-200 is an error
                    raise NetworkError(url, resp.status)

                data = await resp.json()
                vulns = []
                vulns_for_cache = []

                for v in data.get("vulns", []):
                    vuln = self._parse_vulnerability(v)
                    vulns_for_cache.append(vuln.to_dict())
                    # Mark if fixed in the installed version
                    if version and vuln.fixed_version:
                        vuln.is_fixed_in_installed_version = _is_version_fixed(
                            version, vuln.fixed_version
                        )
                    vulns.append(vuln)

                # Cache the raw vulnerability data (without version filtering)
                if self.cache:
                    try:
                        self.cache.set(cache_key, vulns_for_cache, self.CACHE_TTL)
                    except Exception:
                        pass

                return vulns

        except aiohttp.ClientError as e:
            raise NetworkError(url, details=str(e))

    async def batch_check(
        self,
        packages: list[PackageIdentifier],
    ) -> dict[str, list[Vulnerability]]:
        """Check multiple packages for vulnerabilities.

        Args:
            packages: List of packages to check.

        Returns:
            Dict mapping package names to their vulnerabilities,
            with is_fixed_in_installed_version properly set.
        """
        # OSV supports batch queries - query WITHOUT version to get all vulns
        queries = []
        for pkg in packages:
            query: dict[str, Any] = {
                "package": {"name": pkg.name, "ecosystem": "PyPI"},
            }
            # Don't include version - we want ALL vulns then filter
            queries.append(query)

        url = f"{self.BASE_URL}/querybatch"

        try:
            async with self.session.post(
                url,
                headers=self._build_headers(),
                json={"queries": queries},
            ) as resp:
                if resp.status != 200:
                    raise NetworkError(url, resp.status)

                data = await resp.json()
                results = {}

                for i, result in enumerate(data.get("results", [])):
                    pkg = packages[i]
                    vulns = []
                    for v in result.get("vulns", []):
                        vuln = self._parse_vulnerability(v)
                        # Mark if fixed in the installed version
                        if pkg.version and vuln.fixed_version:
                            vuln.is_fixed_in_installed_version = _is_version_fixed(
                                pkg.version, vuln.fixed_version
                            )
                        vulns.append(vuln)
                    results[pkg.name] = vulns

                return results

        except aiohttp.ClientError as e:
            raise NetworkError(url, details=str(e))

    def _parse_vulnerability(self, data: dict[str, Any]) -> Vulnerability:
        """Parse OSV vulnerability data into Vulnerability object.

        Args:
            data: Raw vulnerability data from OSV.

        Returns:
            Vulnerability object.
        """
        # Get the ID (prefer CVE, then GHSA, then OSV ID)
        vuln_id = data.get("id", "")
        aliases = data.get("aliases", [])
        for alias in aliases:
            if alias.startswith("CVE-"):
                vuln_id = alias
                break
            elif alias.startswith("GHSA-") and not vuln_id.startswith("CVE-"):
                vuln_id = alias

        # Determine severity from database_specific or severity field
        severity = self._parse_severity(data)

        # Get affected versions
        affected_versions = self._get_affected_versions(data)

        # Get fixed version
        fixed_version = self._get_fixed_version(data)

        # Parse published date
        published = None
        if pub_str := data.get("published"):
            try:
                published = datetime.fromisoformat(pub_str.replace("Z", "+00:00"))
            except (ValueError, TypeError):
                pass

        # Get CVSS score if available
        cvss_score = None
        for severity_entry in data.get("severity", []):
            if severity_entry.get("type") == "CVSS_V3":
                # Extract score from CVSS vector
                score_str = severity_entry.get("score", "")
                if score_str:
                    try:
                        cvss_score = float(score_str)
                    except ValueError:
                        pass

        return Vulnerability(
            id=vuln_id,
            severity=severity,
            title=data.get("summary", "No summary available"),
            description=data.get("details", ""),
            affected_versions=affected_versions,
            fixed_version=fixed_version,
            published=published,
            references=[ref.get("url", "") for ref in data.get("references", [])],
            cvss_score=cvss_score,
        )

    def _parse_severity(self, data: dict[str, Any]) -> RiskLevel:
        """Parse severity from OSV data.

        Args:
            data: Raw vulnerability data.

        Returns:
            RiskLevel enum value.
        """
        # Check database_specific for severity
        db_specific = data.get("database_specific", {})
        severity_str = db_specific.get("severity", "").upper()

        # Check severity array
        for severity_entry in data.get("severity", []):
            if severity_entry.get("type") == "CVSS_V3":
                score_str = severity_entry.get("score", "")
                try:
                    score = float(score_str)
                    if score >= 9.0:
                        return RiskLevel.CRITICAL
                    elif score >= 7.0:
                        return RiskLevel.HIGH
                    elif score >= 4.0:
                        return RiskLevel.MEDIUM
                    elif score > 0:
                        return RiskLevel.LOW
                except ValueError:
                    pass

        # Map string severity to RiskLevel
        severity_map = {
            "CRITICAL": RiskLevel.CRITICAL,
            "HIGH": RiskLevel.HIGH,
            "MODERATE": RiskLevel.MEDIUM,
            "MEDIUM": RiskLevel.MEDIUM,
            "LOW": RiskLevel.LOW,
        }

        return severity_map.get(severity_str, RiskLevel.MEDIUM)

    def _get_affected_versions(self, data: dict[str, Any]) -> str:
        """Extract affected version specifier from OSV data.

        Args:
            data: Raw vulnerability data.

        Returns:
            Version specifier string.
        """
        affected = data.get("affected", [])
        if not affected:
            return "*"

        version_ranges = []
        for aff in affected:
            ranges = aff.get("ranges", [])
            for range_spec in ranges:
                events = range_spec.get("events", [])
                introduced = None
                fixed = None
                for event in events:
                    if "introduced" in event:
                        introduced = event["introduced"]
                    if "fixed" in event:
                        fixed = event["fixed"]

                if introduced and fixed:
                    version_ranges.append(f">={introduced},<{fixed}")
                elif introduced:
                    version_ranges.append(f">={introduced}")
                elif fixed:
                    version_ranges.append(f"<{fixed}")

            # Also check versions array
            versions = aff.get("versions", [])
            if versions and not version_ranges:
                version_ranges.append(",".join(versions[:5]))  # Limit to 5

        return "; ".join(version_ranges) if version_ranges else "*"

    def _get_fixed_version(self, data: dict[str, Any]) -> str | None:
        """Extract the fixed version from OSV data.

        Args:
            data: Raw vulnerability data.

        Returns:
            Fixed version string or None.
        """
        affected = data.get("affected", [])
        for aff in affected:
            ranges = aff.get("ranges", [])
            for range_spec in ranges:
                events = range_spec.get("events", [])
                for event in events:
                    if "fixed" in event:
                        return event["fixed"]
        return None


class VulnerabilityScanner(Collector):
    """Aggregate vulnerability data from multiple sources.

    Combines results from OSV and potentially other vulnerability
    databases to provide comprehensive security scanning.
    """

    def __init__(
        self,
        session: aiohttp.ClientSession | None = None,
        osv_enabled: bool = True,
        timeout: int = 30,
        cache: "CacheLayer | None" = None,
    ):
        """Initialize the vulnerability scanner.

        Args:
            session: Optional aiohttp session.
            osv_enabled: Whether to enable OSV scanning.
            timeout: Request timeout in seconds.
            cache: Optional cache layer for storing API responses.
        """
        super().__init__(session, timeout)
        self.sources: list[Collector] = []
        self.cache = cache

        if osv_enabled:
            self.sources.append(OSVClient(self.session, timeout, cache=cache))

    async def fetch(self, identifier: str) -> list[Vulnerability]:
        """Fetch vulnerabilities for a package.

        Args:
            identifier: Package name.

        Returns:
            List of Vulnerability objects.
        """
        pkg = PackageIdentifier(name=identifier)
        return await self.scan_package(pkg)

    async def scan_package(
        self,
        package: PackageIdentifier,
    ) -> list[Vulnerability]:
        """Check all sources for vulnerabilities.

        Args:
            package: Package to check (including version for fix detection).

        Returns:
            Deduplicated list of vulnerabilities with is_fixed_in_installed_version set.
        """
        if not self.sources:
            return []

        # Pass both name AND version to enable open vs fixed detection
        tasks = []
        for source in self.sources:
            if isinstance(source, OSVClient):
                # OSVClient.check() handles version comparison
                tasks.append(source.check(package.name, package.version))
            else:
                tasks.append(source.fetch(package.name))

        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Merge and deduplicate by ID
        vulnerabilities: dict[str, Vulnerability] = {}
        for result in results:
            if isinstance(result, Exception):
                continue
            for vuln in result:
                if vuln.id not in vulnerabilities:
                    vulnerabilities[vuln.id] = vuln

        # Sort by severity (most severe first)
        return sorted(
            vulnerabilities.values(),
            key=lambda v: v.severity.sort_order,
        )

    async def scan_packages(
        self,
        packages: list[PackageIdentifier],
    ) -> dict[str, list[Vulnerability]]:
        """Scan multiple packages for vulnerabilities.

        Args:
            packages: List of packages to scan.

        Returns:
            Dict mapping package names to their vulnerabilities.
        """
        results: dict[str, list[Vulnerability]] = {}

        # Use OSV batch API if available
        for source in self.sources:
            if isinstance(source, OSVClient):
                try:
                    batch_results = await source.batch_check(packages)
                    for pkg_name, vulns in batch_results.items():
                        if pkg_name not in results:
                            results[pkg_name] = []
                        # Merge vulnerabilities
                        existing_ids = {v.id for v in results[pkg_name]}
                        for vuln in vulns:
                            if vuln.id not in existing_ids:
                                results[pkg_name].append(vuln)
                except NetworkError:
                    # Fall back to individual queries
                    for pkg in packages:
                        if pkg.name not in results:
                            results[pkg.name] = []
                        try:
                            vulns = await source.check(pkg.name, pkg.version)
                            results[pkg.name].extend(vulns)
                        except NetworkError:
                            pass

        # Sort vulnerabilities by severity for each package
        for pkg_name in results:
            results[pkg_name] = sorted(
                results[pkg_name],
                key=lambda v: v.severity.sort_order,
            )

        return results

    async def close(self) -> None:
        """Close all source clients."""
        for source in self.sources:
            await source.close()
        await super().close()
